/**
 * ===================================================================
 * Auto Logout System Components - Part 2
 * ===================================================================
 * 
 * ActivityTracker and SecurityMonitor classes with advanced
 * monitoring and security features.
 * 
 * @author Auto Logout System
 * @version 2.0.0
 * @license MIT
 */

/**
 * ===================================================================
 * 4. ActivityTracker Class
 * ===================================================================
 * 
 * Comprehensive user activity tracking with offline support,
 * batch sending capabilities, and detailed analytics.
 */
class ActivityTracker extends EventTarget {
    /**
     * @typedef {Object} ActivityTrackerConfig
     * @property {number} batchSize - Number of activities to batch before sending
     * @property {number} sendInterval - Interval to send batched data in milliseconds
     * @property {number} maxStorageSize - Maximum activities to store offline
     * @property {string} apiEndpoint - Server endpoint for sending data
     * @property {boolean} enableOfflineStorage - Enable offline activity storage
     * @property {boolean} enableAnalytics - Enable detailed analytics
     * @property {string[]} trackingEvents - Events to track
     */

    /**
     * Initialize ActivityTracker
     * @param {ActivityTrackerConfig} config - Configuration object
     */
    constructor(config = {}) {\n        super();\n        \n        this.config = {\n            batchSize: 10,\n            sendInterval: 30 * 1000,           // 30 seconds\n            maxStorageSize: 1000,\n            maxRetryAttempts: 3,\n            retryDelay: 5000,\n            apiEndpoint: '/api/activity/track',\n            enableOfflineStorage: true,\n            enableAnalytics: true,\n            enableGeolocation: false,\n            trackingEvents: [\n                'page_view', 'click', 'form_submit', 'scroll',\n                'keyboard_input', 'mouse_move', 'focus_change',\n                'visibility_change', 'network_change', 'error'\n            ],\n            sensitiveDataFilter: [\n                'password', 'token', 'key', 'secret', 'credential'\n            ],\n            ...config\n        };\n\n        this.state = {\n            isTracking: false,\n            sessionId: null,\n            userId: null,\n            activities: [],\n            offlineQueue: [],\n            sendTimer: null,\n            retryQueue: [],\n            statistics: {\n                totalActivities: 0,\n                successfulSends: 0,\n                failedSends: 0,\n                offlineActivities: 0\n            },\n            networkStatus: navigator.onLine\n        };\n\n        this.boundNetworkHandler = this.handleNetworkChange.bind(this);\n        this.boundVisibilityHandler = this.handleVisibilityChange.bind(this);\n        this.boundBeforeUnloadHandler = this.handleBeforeUnload.bind(this);\n        \n        this.initializeTracking();\n    }\n\n    /**\n     * Start activity tracking\n     * @param {Object} sessionInfo - Session information\n     * @returns {Promise<void>}\n     */\n    async startTracking(sessionInfo = {}) {\n        try {\n            if (this.state.isTracking) {\n                console.warn('Activity tracking is already active');\n                return;\n            }\n\n            this.state.isTracking = true;\n            this.state.sessionId = sessionInfo.sessionId || this.generateId();\n            this.state.userId = sessionInfo.userId || 'anonymous';\n\n            // Load offline queue\n            await this.loadOfflineQueue();\n\n            // Start monitoring\n            this.startEventListeners();\n            this.startBatchSending();\n\n            // Track session start\n            await this.trackActivity('session_start', {\n                sessionId: this.state.sessionId,\n                userId: this.state.userId,\n                userAgent: navigator.userAgent,\n                viewport: {\n                    width: window.innerWidth,\n                    height: window.innerHeight\n                },\n                screen: {\n                    width: screen.width,\n                    height: screen.height,\n                    colorDepth: screen.colorDepth\n                },\n                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n                language: navigator.language\n            });\n\n            this.dispatchEvent(new CustomEvent('tracking:started', {\n                detail: { sessionId: this.state.sessionId }\n            }));\n\n            console.log(`Activity tracking started for session: ${this.state.sessionId}`);\n\n        } catch (error) {\n            console.error('Failed to start activity tracking:', error);\n            throw new Error(`ActivityTracker start failed: ${error.message}`);\n        }\n    }\n\n    /**\n     * Stop activity tracking\n     * @returns {Promise<void>}\n     */\n    async stopTracking() {\n        try {\n            if (!this.state.isTracking) {\n                return;\n            }\n\n            // Track session end\n            await this.trackActivity('session_end', {\n                sessionId: this.state.sessionId,\n                duration: Date.now() - this.getSessionStartTime(),\n                statistics: this.getStatistics()\n            });\n\n            // Send remaining activities\n            await this.sendBatch(true);\n\n            // Stop monitoring\n            this.stopEventListeners();\n            this.stopBatchSending();\n\n            // Save offline queue\n            await this.saveOfflineQueue();\n\n            this.state.isTracking = false;\n\n            this.dispatchEvent(new CustomEvent('tracking:stopped', {\n                detail: {\n                    sessionId: this.state.sessionId,\n                    statistics: this.state.statistics\n                }\n            }));\n\n            console.log('Activity tracking stopped');\n\n        } catch (error) {\n            console.error('Failed to stop activity tracking:', error);\n        }\n    }\n\n    /**\n     * Track a specific activity\n     * @param {string} type - Activity type\n     * @param {Object} data - Activity data\n     * @param {Object} options - Tracking options\n     * @returns {Promise<void>}\n     */\n    async trackActivity(type, data = {}, options = {}) {\n        try {\n            if (!this.state.isTracking && type !== 'session_start') {\n                return;\n            }\n\n            // Filter sensitive data\n            const filteredData = this.filterSensitiveData(data);\n\n            const activity = {\n                id: this.generateId(),\n                type,\n                timestamp: Date.now(),\n                sessionId: this.state.sessionId,\n                userId: this.state.userId,\n                url: window.location.href,\n                referrer: document.referrer,\n                data: filteredData,\n                metadata: {\n                    userAgent: navigator.userAgent,\n                    viewport: {\n                        width: window.innerWidth,\n                        height: window.innerHeight\n                    },\n                    ...options.metadata\n                }\n            };\n\n            // Add geolocation if enabled\n            if (this.config.enableGeolocation && options.includeLocation) {\n                activity.location = await this.getCurrentLocation().catch(() => null);\n            }\n\n            // Add to batch\n            this.state.activities.push(activity);\n            this.state.statistics.totalActivities++;\n\n            // Immediate send for critical activities\n            if (options.immediate || type === 'error' || type === 'security_violation') {\n                await this.sendActivity(activity);\n            }\n\n            this.dispatchEvent(new CustomEvent('activity:tracked', {\n                detail: { activity }\n            }));\n\n        } catch (error) {\n            console.error('Failed to track activity:', error);\n        }\n    }\n\n    /**\n     * Track page view\n     * @param {Object} pageData - Page information\n     * @returns {Promise<void>}\n     */\n    async trackPageView(pageData = {}) {\n        const data = {\n            title: document.title,\n            url: window.location.href,\n            pathname: window.location.pathname,\n            search: window.location.search,\n            hash: window.location.hash,\n            loadTime: performance.now(),\n            ...pageData\n        };\n\n        await this.trackActivity('page_view', data);\n    }\n\n    /**\n     * Track user interaction\n     * @param {string} element - Element identifier\n     * @param {string} action - Action type\n     * @param {Object} details - Additional details\n     * @returns {Promise<void>}\n     */\n    async trackInteraction(element, action, details = {}) {\n        const data = {\n            element,\n            action,\n            timestamp: Date.now(),\n            ...details\n        };\n\n        await this.trackActivity('interaction', data);\n    }\n\n    /**\n     * Track form submission\n     * @param {string} formId - Form identifier\n     * @param {Object} formData - Form data (filtered)\n     * @returns {Promise<void>}\n     */\n    async trackFormSubmission(formId, formData = {}) {\n        const data = {\n            formId,\n            fields: Object.keys(formData),\n            fieldCount: Object.keys(formData).length,\n            // Don't send actual form values for privacy\n            timestamp: Date.now()\n        };\n\n        await this.trackActivity('form_submit', data);\n    }\n\n    /**\n     * Track error occurrence\n     * @param {Error} error - Error object\n     * @param {Object} context - Error context\n     * @returns {Promise<void>}\n     */\n    async trackError(error, context = {}) {\n        const data = {\n            message: error.message,\n            stack: error.stack,\n            name: error.name,\n            url: window.location.href,\n            lineNumber: error.lineNumber || null,\n            columnNumber: error.columnNumber || null,\n            context,\n            timestamp: Date.now()\n        };\n\n        await this.trackActivity('error', data, { immediate: true });\n    }\n\n    /**\n     * Send individual activity\n     * @param {Object} activity - Activity object\n     * @returns {Promise<boolean>} Success status\n     * @private\n     */\n    async sendActivity(activity) {\n        try {\n            if (!this.state.networkStatus) {\n                this.addToOfflineQueue([activity]);\n                return false;\n            }\n\n            const response = await fetch(this.config.apiEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Session-ID': this.state.sessionId\n                },\n                body: JSON.stringify({ activities: [activity] })\n            });\n\n            if (response.ok) {\n                this.state.statistics.successfulSends++;\n                return true;\n            } else {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n        } catch (error) {\n            console.error('Failed to send activity:', error);\n            this.addToOfflineQueue([activity]);\n            this.state.statistics.failedSends++;\n            return false;\n        }\n    }\n\n    /**\n     * Send batched activities\n     * @param {boolean} force - Force send regardless of batch size\n     * @returns {Promise<boolean>} Success status\n     * @private\n     */\n    async sendBatch(force = false) {\n        try {\n            if (this.state.activities.length === 0) {\n                return true;\n            }\n\n            if (!force && this.state.activities.length < this.config.batchSize) {\n                return true;\n            }\n\n            if (!this.state.networkStatus) {\n                this.addToOfflineQueue([...this.state.activities]);\n                this.state.activities = [];\n                return false;\n            }\n\n            const batch = [...this.state.activities];\n            this.state.activities = [];\n\n            const response = await this.sendWithRetry(batch);\n            \n            if (response) {\n                this.state.statistics.successfulSends += batch.length;\n                \n                this.dispatchEvent(new CustomEvent('batch:sent', {\n                    detail: { \n                        count: batch.length,\n                        statistics: this.state.statistics\n                    }\n                }));\n                \n                return true;\n            } else {\n                this.addToOfflineQueue(batch);\n                this.state.statistics.failedSends += batch.length;\n                return false;\n            }\n\n        } catch (error) {\n            console.error('Failed to send batch:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Send with retry mechanism\n     * @param {Array} activities - Activities to send\n     * @param {number} attempt - Current attempt number\n     * @returns {Promise<boolean>} Success status\n     * @private\n     */\n    async sendWithRetry(activities, attempt = 1) {\n        try {\n            const response = await fetch(this.config.apiEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Session-ID': this.state.sessionId,\n                    'X-Retry-Attempt': attempt.toString()\n                },\n                body: JSON.stringify({ \n                    activities,\n                    metadata: {\n                        batchId: this.generateId(),\n                        timestamp: Date.now(),\n                        attempt\n                    }\n                })\n            });\n\n            if (response.ok) {\n                return true;\n            } else if (attempt < this.config.maxRetryAttempts) {\n                // Exponential backoff\n                const delay = this.config.retryDelay * Math.pow(2, attempt - 1);\n                await this.sleep(delay);\n                return this.sendWithRetry(activities, attempt + 1);\n            } else {\n                throw new Error(`Max retry attempts reached. HTTP ${response.status}`);\n            }\n\n        } catch (error) {\n            if (attempt < this.config.maxRetryAttempts) {\n                const delay = this.config.retryDelay * Math.pow(2, attempt - 1);\n                await this.sleep(delay);\n                return this.sendWithRetry(activities, attempt + 1);\n            } else {\n                console.error('Send with retry failed:', error);\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Add activities to offline queue\n     * @param {Array} activities - Activities to queue\n     * @private\n     */\n    addToOfflineQueue(activities) {\n        this.state.offlineQueue.push(...activities);\n        this.state.statistics.offlineActivities += activities.length;\n\n        // Limit queue size\n        if (this.state.offlineQueue.length > this.config.maxStorageSize) {\n            const excess = this.state.offlineQueue.length - this.config.maxStorageSize;\n            this.state.offlineQueue.splice(0, excess);\n        }\n\n        this.dispatchEvent(new CustomEvent('activities:queued', {\n            detail: { \n                count: activities.length,\n                queueSize: this.state.offlineQueue.length\n            }\n        }));\n    }\n\n    /**\n     * Process offline queue when network is available\n     * @returns {Promise<void>}\n     * @private\n     */\n    async processOfflineQueue() {\n        if (!this.state.networkStatus || this.state.offlineQueue.length === 0) {\n            return;\n        }\n\n        console.log(`Processing ${this.state.offlineQueue.length} offline activities`);\n\n        const batchSize = this.config.batchSize;\n        const batches = [];\n        \n        for (let i = 0; i < this.state.offlineQueue.length; i += batchSize) {\n            batches.push(this.state.offlineQueue.slice(i, i + batchSize));\n        }\n\n        let successCount = 0;\n        \n        for (const batch of batches) {\n            const success = await this.sendWithRetry(batch);\n            if (success) {\n                successCount += batch.length;\n            } else {\n                // Re-queue failed batch\n                this.state.retryQueue.push(...batch);\n            }\n        }\n\n        // Update queue and statistics\n        this.state.offlineQueue = [...this.state.retryQueue];\n        this.state.retryQueue = [];\n        this.state.statistics.offlineActivities -= successCount;\n        this.state.statistics.successfulSends += successCount;\n\n        this.dispatchEvent(new CustomEvent('offline:processed', {\n            detail: {\n                processed: successCount,\n                remaining: this.state.offlineQueue.length\n            }\n        }));\n    }\n\n    /**\n     * Initialize event tracking\n     * @private\n     */\n    initializeTracking() {\n        // Network status monitoring\n        window.addEventListener('online', this.boundNetworkHandler);\n        window.addEventListener('offline', this.boundNetworkHandler);\n        \n        // Page visibility monitoring\n        document.addEventListener('visibilitychange', this.boundVisibilityHandler);\n        \n        // Before unload handling\n        window.addEventListener('beforeunload', this.boundBeforeUnloadHandler);\n        \n        // Global error handling\n        window.addEventListener('error', (event) => {\n            this.trackError(event.error || new Error(event.message), {\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno\n            });\n        });\n\n        // Unhandled promise rejection\n        window.addEventListener('unhandledrejection', (event) => {\n            this.trackError(new Error(event.reason), {\n                type: 'unhandled_promise_rejection',\n                reason: event.reason\n            });\n        });\n    }\n\n    /**\n     * Start event listeners for activity tracking\n     * @private\n     */\n    startEventListeners() {\n        // Click tracking\n        document.addEventListener('click', (event) => {\n            this.trackInteraction(\n                this.getElementSelector(event.target),\n                'click',\n                {\n                    x: event.clientX,\n                    y: event.clientY,\n                    button: event.button\n                }\n            );\n        }, { passive: true });\n\n        // Form submission tracking\n        document.addEventListener('submit', (event) => {\n            const form = event.target;\n            if (form.tagName === 'FORM') {\n                this.trackFormSubmission(\n                    form.id || form.name || 'unnamed_form',\n                    this.getFormData(form)\n                );\n            }\n        }, { passive: true });\n\n        // Scroll tracking (throttled)\n        let scrollTimeout;\n        document.addEventListener('scroll', () => {\n            clearTimeout(scrollTimeout);\n            scrollTimeout = setTimeout(() => {\n                this.trackActivity('scroll', {\n                    scrollY: window.scrollY,\n                    scrollX: window.scrollX,\n                    documentHeight: document.documentElement.scrollHeight,\n                    windowHeight: window.innerHeight\n                });\n            }, 1000);\n        }, { passive: true });\n\n        // Focus/blur tracking\n        window.addEventListener('focus', () => {\n            this.trackActivity('focus', { type: 'window_focus' });\n        });\n\n        window.addEventListener('blur', () => {\n            this.trackActivity('focus', { type: 'window_blur' });\n        });\n    }\n\n    /**\n     * Stop event listeners\n     * @private\n     */\n    stopEventListeners() {\n        // Note: In a real implementation, you'd want to keep references\n        // to the actual handler functions to properly remove them\n        console.log('Event listeners stopped');\n    }\n\n    /**\n     * Start batch sending timer\n     * @private\n     */\n    startBatchSending() {\n        this.state.sendTimer = setInterval(() => {\n            this.sendBatch();\n        }, this.config.sendInterval);\n    }\n\n    /**\n     * Stop batch sending timer\n     * @private\n     */\n    stopBatchSending() {\n        if (this.state.sendTimer) {\n            clearInterval(this.state.sendTimer);\n            this.state.sendTimer = null;\n        }\n    }\n\n    /**\n     * Handle network status change\n     * @private\n     */\n    handleNetworkChange() {\n        const wasOnline = this.state.networkStatus;\n        this.state.networkStatus = navigator.onLine;\n\n        this.trackActivity('network_change', {\n            status: this.state.networkStatus ? 'online' : 'offline',\n            previousStatus: wasOnline ? 'online' : 'offline'\n        });\n\n        if (this.state.networkStatus && !wasOnline) {\n            // Network came back online, process offline queue\n            setTimeout(() => {\n                this.processOfflineQueue();\n            }, 1000);\n        }\n\n        this.dispatchEvent(new CustomEvent('network:changed', {\n            detail: {\n                online: this.state.networkStatus,\n                queueSize: this.state.offlineQueue.length\n            }\n        }));\n    }\n\n    /**\n     * Handle visibility change\n     * @private\n     */\n    handleVisibilityChange() {\n        this.trackActivity('visibility_change', {\n            hidden: document.hidden,\n            visibilityState: document.visibilityState\n        });\n    }\n\n    /**\n     * Handle before unload\n     * @private\n     */\n    handleBeforeUnload() {\n        // Send remaining activities synchronously\n        if (this.state.activities.length > 0) {\n            navigator.sendBeacon(\n                this.config.apiEndpoint,\n                JSON.stringify({\n                    activities: this.state.activities,\n                    metadata: { type: 'page_unload' }\n                })\n            );\n        }\n\n        this.saveOfflineQueue();\n    }\n\n    /**\n     * Load offline queue from storage\n     * @returns {Promise<void>}\n     * @private\n     */\n    async loadOfflineQueue() {\n        try {\n            if (!this.config.enableOfflineStorage) {\n                return;\n            }\n\n            const stored = localStorage.getItem('activity_offline_queue');\n            if (stored) {\n                this.state.offlineQueue = JSON.parse(stored);\n                this.state.statistics.offlineActivities = this.state.offlineQueue.length;\n            }\n        } catch (error) {\n            console.error('Failed to load offline queue:', error);\n        }\n    }\n\n    /**\n     * Save offline queue to storage\n     * @returns {Promise<void>}\n     * @private\n     */\n    async saveOfflineQueue() {\n        try {\n            if (!this.config.enableOfflineStorage) {\n                return;\n            }\n\n            localStorage.setItem(\n                'activity_offline_queue',\n                JSON.stringify(this.state.offlineQueue)\n            );\n        } catch (error) {\n            console.error('Failed to save offline queue:', error);\n        }\n    }\n\n    /**\n     * Filter sensitive data from activity data\n     * @param {Object} data - Raw activity data\n     * @returns {Object} Filtered data\n     * @private\n     */\n    filterSensitiveData(data) {\n        const filtered = { ...data };\n        \n        const filterValue = (obj, key) => {\n            if (typeof obj[key] === 'string') {\n                const lowerKey = key.toLowerCase();\n                if (this.config.sensitiveDataFilter.some(filter => lowerKey.includes(filter))) {\n                    obj[key] = '[FILTERED]';\n                }\n            } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n                Object.keys(obj[key]).forEach(subKey => {\n                    filterValue(obj[key], subKey);\n                });\n            }\n        };\n\n        Object.keys(filtered).forEach(key => {\n            filterValue(filtered, key);\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Get element selector for tracking\n     * @param {Element} element - DOM element\n     * @returns {string} Element selector\n     * @private\n     */\n    getElementSelector(element) {\n        if (element.id) {\n            return `#${element.id}`;\n        }\n        \n        if (element.className) {\n            return `.${element.className.split(' ').join('.')}`;\n        }\n        \n        let selector = element.tagName.toLowerCase();\n        let parent = element.parentElement;\n        \n        while (parent && parent !== document.body) {\n            selector = `${parent.tagName.toLowerCase()} > ${selector}`;\n            parent = parent.parentElement;\n        }\n        \n        return selector;\n    }\n\n    /**\n     * Get form data (filtered)\n     * @param {HTMLFormElement} form - Form element\n     * @returns {Object} Form data\n     * @private\n     */\n    getFormData(form) {\n        const formData = new FormData(form);\n        const data = {};\n        \n        for (let [key, value] of formData.entries()) {\n            // Don't store actual values, just field names for privacy\n            data[key] = typeof value === 'string' ? value.length : '[FILE]';\n        }\n        \n        return data;\n    }\n\n    /**\n     * Get current geolocation\n     * @returns {Promise<Object>} Location coordinates\n     * @private\n     */\n    getCurrentLocation() {\n        return new Promise((resolve, reject) => {\n            if (!navigator.geolocation) {\n                reject(new Error('Geolocation not supported'));\n                return;\n            }\n\n            navigator.geolocation.getCurrentPosition(\n                (position) => {\n                    resolve({\n                        latitude: position.coords.latitude,\n                        longitude: position.coords.longitude,\n                        accuracy: position.coords.accuracy,\n                        timestamp: position.timestamp\n                    });\n                },\n                (error) => {\n                    reject(error);\n                },\n                {\n                    timeout: 10000,\n                    maximumAge: 300000 // 5 minutes\n                }\n            );\n        });\n    }\n\n    /**\n     * Get session start time\n     * @returns {number} Session start timestamp\n     * @private\n     */\n    getSessionStartTime() {\n        // This would typically be stored when session starts\n        return parseInt(localStorage.getItem('session_start_time') || Date.now());\n    }\n\n    /**\n     * Sleep utility function\n     * @param {number} ms - Milliseconds to sleep\n     * @returns {Promise<void>}\n     * @private\n     */\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n     * Generate unique ID\n     * @returns {string} Unique identifier\n     * @private\n     */\n    generateId() {\n        return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    /**\n     * Get current statistics\n     * @returns {Object} Current tracking statistics\n     */\n    getStatistics() {\n        return {\n            ...this.state.statistics,\n            queueSize: this.state.offlineQueue.length,\n            batchSize: this.state.activities.length,\n            isTracking: this.state.isTracking,\n            networkStatus: this.state.networkStatus\n        };\n    }\n\n    /**\n     * Clear all stored data\n     * @returns {void}\n     */\n    clearData() {\n        this.state.activities = [];\n        this.state.offlineQueue = [];\n        this.state.statistics = {\n            totalActivities: 0,\n            successfulSends: 0,\n            failedSends: 0,\n            offlineActivities: 0\n        };\n        \n        localStorage.removeItem('activity_offline_queue');\n        \n        this.dispatchEvent(new CustomEvent('data:cleared'));\n    }\n\n    /**\n     * Update configuration\n     * @param {Partial<ActivityTrackerConfig>} newConfig - New configuration\n     * @returns {void}\n     */\n    updateConfig(newConfig) {\n        const wasTracking = this.state.isTracking;\n        \n        if (wasTracking) {\n            this.stopTracking();\n        }\n        \n        this.config = { ...this.config, ...newConfig };\n        \n        if (wasTracking) {\n            this.startTracking({\n                sessionId: this.state.sessionId,\n                userId: this.state.userId\n            });\n        }\n    }\n}\n\n/**\n * Export ActivityTracker\n */\nwindow.ActivityTracker = ActivityTracker;\n\n// Export for ES6 modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { ActivityTracker };\n}